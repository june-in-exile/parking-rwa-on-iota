{
  "version": 3,
  "sources": ["../../src/iota-names-client.ts"],
  "sourcesContent": ["// Copyright (c) Mysten Labs, Inc.\n// Modifications Copyright (c) 2025 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bcs } from '@iota/iota-sdk/bcs';\nimport { IotaGraphQLClient } from '@iota/iota-sdk/graphql';\nimport { graphql } from '@iota/iota-sdk/graphql/schemas/2025.2';\nimport { fromB64, toB64 } from '@iota/iota-sdk/utils';\nimport { blake2b } from '@noble/hashes/blake2';\nimport { bytesToHex, hexToBytes } from '@noble/hashes/utils';\n\nimport { CouponBcs, CouponHouseBcs, DummyFieldBcs, NameBcs } from './bcs.js';\nimport { ALLOWED_METADATA, packages } from './constants.js';\nimport { applyCouponsToPrice, validateCoupons } from './coupons.js';\nimport {\n    getConfigType,\n    getCoreConfigType,\n    getNameType,\n    getPricelistConfigType,\n    getRenewalPricelistConfigType,\n    isSubname,\n    validateYears,\n} from './helpers.js';\nimport type {\n    Coupon,\n    CouponHouse,\n    IotaNamesClientConfig,\n    IotaNamesCoreConfig,\n    IotaNamesPriceList,\n    NameRecord,\n    PackageInfo,\n} from './types.js';\nimport { isValidIotaName, normalizeIotaName, validateIotaName } from './utils.js';\n\n/// The IotaNamesClient is the main entry point for the IotaNames SDK.\n/// It allows you to interact with IOTA-Names.\nexport class IotaNamesClient {\n    graphQlClient: IotaGraphQLClient;\n    config: PackageInfo;\n\n    constructor(config: IotaNamesClientConfig) {\n        this.graphQlClient = config.graphQlClient;\n\n        if ('network' in config) {\n            this.config = packages[config.network as keyof typeof packages];\n        } else {\n            this.config = config.packageInfo;\n        }\n    }\n\n    /**\n     * Returns the core config of IOTA Names.\n     */\n    async getCoreConfig(): Promise<IotaNamesCoreConfig> {\n        if (!this.config.iotaNamesObjectId) throw new Error('IotaNames object ID is not set');\n        if (!this.config.packageId) throw new Error('IotaNames package ID is not set');\n\n        const coreConfigBcsB64 = toB64(\n            DummyFieldBcs.serialize({\n                dummy_field: false,\n            }).toBytes(),\n        );\n\n        const coreConfigResponse: any = await this.graphQlClient.query({\n            query: graphql(`\n                query getCoreConfig($parentId: IotaAddress!, $name: DynamicFieldName!) {\n                    owner(address: $parentId) {\n                        address\n                        dynamicField(name: $name) {\n                            value {\n                                ... on MoveValue {\n                                    json\n                                }\n                            }\n                        }\n                    }\n                }\n            `),\n            variables: {\n                parentId: this.config.iotaNamesObjectId,\n                name: {\n                    type: getConfigType(\n                        this.config.packageId,\n                        getCoreConfigType(this.config.packageId),\n                    ),\n                    bcs: coreConfigBcsB64,\n                },\n            },\n        });\n\n        const coreConfig = coreConfigResponse?.data?.owner?.dynamicField?.value?.json;\n\n        if (!coreConfig) {\n            throw new Error('Core config not found or is invalid');\n        }\n\n        return coreConfig;\n    }\n\n    /**\n     * Returns the price list for IOTA names in the base asset.\n     */\n    // Format:\n    // {\n    // \t[ 3, 3 ] => 500000000,\n    // \t[ 4, 4 ] => 100000000,\n    // \t[ 5, 63 ] => 20000000\n    // }\n    async getPriceList(): Promise<IotaNamesPriceList> {\n        if (!this.config.iotaNamesObjectId) throw new Error('IotaNames object ID is not set');\n        if (!this.config.packageId) throw new Error('IotaNames package ID is not set');\n\n        const pricingConfigBcsB64 = toB64(\n            DummyFieldBcs.serialize({\n                dummy_field: false,\n            }).toBytes(),\n        );\n\n        const priceListResponse: any = await this.graphQlClient.query({\n            query: graphql(`\n                query getPriceList($parentId: IotaAddress!, $name: DynamicFieldName!) {\n                    owner(address: $parentId) {\n                        address\n                        dynamicField(name: $name) {\n                            value {\n                                ... on MoveValue {\n                                    json\n                                }\n                            }\n                        }\n                    }\n                }\n            `),\n            variables: {\n                parentId: this.config.iotaNamesObjectId,\n                name: {\n                    type: getConfigType(\n                        this.config.packageId,\n                        getPricelistConfigType(this.config.packageId),\n                    ),\n                    bcs: pricingConfigBcsB64,\n                },\n            },\n        });\n\n        const priceList = priceListResponse?.data?.owner?.dynamicField?.value?.json?.pricing;\n        const contents = priceList?.contents;\n\n        // Ensure the content exists\n        if (!contents) {\n            throw new Error('Price list not found or content is invalid');\n        }\n\n        const priceMap = new Map();\n        for (const entry of contents) {\n            const { pos0, pos1 } = entry.key;\n            const key = [Number(pos0), Number(pos1)]; // Convert keys to numbers\n            const value = Number(entry.value); // Convert value to a number\n\n            priceMap.set(key, value);\n        }\n\n        return priceMap;\n    }\n\n    /**\n     * Returns the renewal price list for IOTA names in the base asset.\n     */\n    // Format:\n    // {\n    // \t[ 3, 3 ] => 500000000000,\n    // \t[ 4, 4 ] => 250000000000,\n    // \t[ 5, 63 ] => 50000000000\n    // }\n    async getRenewalPriceList(): Promise<IotaNamesPriceList> {\n        if (!this.config.iotaNamesObjectId) throw new Error('IotaNames object ID is not set');\n        if (!this.config.packageId) throw new Error('IotaNames package ID is not set');\n\n        const pricingConfigBcsB64 = toB64(\n            DummyFieldBcs.serialize({\n                dummy_field: false,\n            }).toBytes(),\n        );\n\n        const priceListResponse: any = await this.graphQlClient.query({\n            query: graphql(`\n                query getRenewalPriceList($parentId: IotaAddress!, $name: DynamicFieldName!) {\n                    owner(address: $parentId) {\n                        address\n                        dynamicField(name: $name) {\n                            value {\n                                ... on MoveValue {\n                                    json\n                                }\n                            }\n                        }\n                    }\n                }\n            `),\n            variables: {\n                parentId: this.config.iotaNamesObjectId,\n                name: {\n                    type: getConfigType(\n                        this.config.packageId,\n                        getRenewalPricelistConfigType(this.config.packageId),\n                    ),\n                    bcs: pricingConfigBcsB64,\n                },\n            },\n        });\n\n        const priceList =\n            priceListResponse?.data?.owner?.dynamicField?.value?.json?.config?.pricing;\n        const contents = priceList?.contents;\n\n        // Ensure the content exists\n        if (!contents) {\n            throw new Error('Price list not found or content is invalid');\n        }\n\n        const priceMap = new Map();\n        for (const entry of contents) {\n            const { pos0, pos1 } = entry.key;\n            const key = [Number(pos0), Number(pos1)]; // Convert keys to numbers\n            const value = Number(entry.value); // Convert value to a number\n\n            priceMap.set(key, value);\n        }\n\n        return priceMap;\n    }\n\n    async getDefaultName(address: string): Promise<string | null> {\n        const response: any = await this.graphQlClient.query({\n            query: graphql(`\n                query resolveNameServiceName($address: IotaAddress!, $nameFormat: NameFormat) {\n                    address(address: $address) {\n                        iotaNamesDefaultName(format: $nameFormat)\n                    }\n                }\n            `),\n            variables: {\n                address,\n            },\n        });\n\n        const defaultName = response?.data?.address?.iotaNamesDefaultName ?? null;\n\n        return defaultName;\n    }\n\n    async getNameRecord(name: string): Promise<NameRecord | null> {\n        if (!isValidIotaName(name)) throw new Error('Invalid IOTA name');\n        if (!this.config.registryTableId) throw new Error('IotaNames package ID is not set');\n\n        const nameBcsB64 = toB64(\n            NameBcs.serialize({\n                labels: normalizeIotaName(name, 'dot').split('.').reverse(),\n            }).toBytes(),\n        );\n\n        const nameRecordResponse: any = await this.graphQlClient.query({\n            query: graphql(`\n                query getNameRecord($parentId: IotaAddress!, $name: DynamicFieldName!) {\n                    owner(address: $parentId) {\n                        address\n                        dynamicField(name: $name) {\n                            value {\n                                ... on MoveValue {\n                                    json\n                                }\n                            }\n                        }\n                    }\n                }\n            `),\n            variables: {\n                parentId: this.config.registryTableId,\n                name: {\n                    type: getNameType(this.config.packageId),\n                    bcs: nameBcsB64,\n                },\n            },\n        });\n\n        const nameRecord = nameRecordResponse.data?.owner?.dynamicField?.value?.json;\n\n        // in case the name record is not found, return null\n        if (!nameRecord) return null;\n\n        const nameRecordData = nameRecord.data?.contents;\n\n        if (nameRecord.error || !nameRecordData)\n            throw new Error('Name record not found. This name is not registered.');\n\n        const data: Record<string, string> = {};\n\n        if (nameRecordData) {\n            nameRecordData.forEach((field: any) => {\n                if (field.key) {\n                    data[field.key as string] = field.value;\n                }\n            });\n        }\n\n        return {\n            name,\n            nftId: nameRecord?.nft_id,\n            targetAddress: nameRecord?.target_address!,\n            expirationTimestampMs: Number(nameRecord?.expiration_timestamp_ms),\n            data,\n            avatar: data[ALLOWED_METADATA.avatar],\n        };\n    }\n\n    async getCouponHouse(): Promise<CouponHouse> {\n        if (!this.config.iotaNamesObjectId) throw new Error('IotaNames object ID is not set');\n        if (!this.config.packageId) throw new Error('IotaNames package ID is not set');\n        if (!this.config.couponsPackageId) throw new Error('Coupon package ID is not set');\n\n        const iotaNamesObjectId = this.config.iotaNamesObjectId;\n        const packageId = this.config.packageId;\n        const couponsPackageId = this.config.couponsPackageId;\n\n        const DummyFieldB64 = DummyFieldBcs.serialize({ dummy_field: false }).toBase64();\n\n        const couponHouseResponse = await this.graphQlClient.query<{\n            owner: { dynamicField: { value: { bcs: string } } };\n        }>({\n            query: graphql(`\n                query getIotaNamesCouponHouseRegistryKey(\n                    $parentId: IotaAddress!\n                    $name: DynamicFieldName!\n                ) {\n                    owner(address: $parentId) {\n                        dynamicField(name: $name) {\n                            value {\n                                ... on MoveValue {\n                                    bcs\n                                }\n                            }\n                        }\n                    }\n                }\n            `),\n            variables: {\n                parentId: iotaNamesObjectId,\n                name: {\n                    type: `${packageId}::iota_names::RegistryKey<${couponsPackageId}::coupon_house::CouponHouse>`,\n                    bcs: DummyFieldB64,\n                },\n            },\n        });\n\n        const couponsHouseDynamicFieldBcsValue =\n            couponHouseResponse?.data?.owner?.dynamicField?.value?.bcs;\n\n        if (!couponsHouseDynamicFieldBcsValue) {\n            throw new Error('Coupon house not found or is invalid');\n        }\n\n        return CouponHouseBcs.parse(fromB64(couponsHouseDynamicFieldBcsValue));\n    }\n\n    async resolveCoupon(couponCode: string): Promise<Coupon | null> {\n        const couponHouse = await this.getCouponHouse();\n        const couponsTableId = couponHouse?.coupons?.coupons?.id.id.bytes;\n\n        if (!couponsTableId) {\n            throw new Error('Coupons table ID not found in the coupon house');\n        }\n\n        const couponCodeHash = bytesToHex(blake2b(couponCode, { dkLen: 32 }));\n        const couponCodeBytes = hexToBytes(couponCodeHash);\n\n        const couponCodeB64 = bcs.vector(bcs.u8()).serialize(couponCodeBytes).toBase64();\n\n        const couponResponse = await this.graphQlClient.query<{\n            owner: { dynamicField: { value: { bcs: string } } };\n        }>({\n            query: graphql(`\n                query getCouponBcs($parentId: IotaAddress!, $name: DynamicFieldName!) {\n                    owner(address: $parentId) {\n                        dynamicField(name: $name) {\n                            value {\n                                ... on MoveValue {\n                                    bcs\n                                }\n                            }\n                        }\n                    }\n                }\n            `),\n            variables: {\n                parentId: couponsTableId,\n                name: {\n                    type: 'vector<u8>',\n                    bcs: couponCodeB64,\n                },\n            },\n        });\n\n        const couponBcsBase64 = couponResponse?.data?.owner?.dynamicField?.value?.bcs;\n\n        if (!couponBcsBase64) {\n            return null;\n        }\n\n        const couponData = CouponBcs.parse(fromB64(couponBcsBase64));\n\n        return { ...couponData, couponCode };\n    }\n\n    /**\n     * Calculates the registration or renewal price for an SLN (Second Level Name).\n     * It expects a name, the number of years and a `IotaNamesPriceList` object,\n     * as returned from `iotaNamesClient.getPriceList()` function, or `iotaNames.getRenewalPriceList()` function.\n     *\n     * It throws an error:\n     * 1. if the name is a subname\n     * 2. if the name is not a valid IOTA name\n     * 3. if the years are not between 1 and 5\n     */\n    async calculatePrice({\n        name,\n        years,\n        isRegistration = true,\n    }: {\n        name: string;\n        years: number;\n        isRegistration?: boolean;\n    }) {\n        if (!isValidIotaName(name)) {\n            throw new Error('Invalid IOTA names');\n        }\n        validateYears(years);\n\n        if (isSubname(name)) {\n            throw new Error('Subnames do not have a registration fee');\n        }\n\n        const length = normalizeIotaName(name, 'dot').split('.')[0].length;\n        const priceList = await this.getPriceList();\n        const renewalPriceList = await this.getRenewalPriceList();\n        let yearsRemain = years;\n        let price = 0;\n\n        if (isRegistration) {\n            for (const [[minLength, maxLength], pricePerYear] of priceList.entries()) {\n                if (length >= minLength && length <= maxLength) {\n                    price += pricePerYear; // Registration is always 1 year\n                    yearsRemain -= 1;\n                    break;\n                }\n            }\n        }\n\n        for (const [[minLength, maxLength], pricePerYear] of renewalPriceList.entries()) {\n            if (length >= minLength && length <= maxLength) {\n                price += yearsRemain * pricePerYear;\n                break;\n            }\n        }\n\n        return price;\n    }\n\n    async calculateDiscountedPrice({\n        coupons,\n        name,\n        years,\n        isRegistration = true,\n        address,\n    }: {\n        coupons: Coupon[] | string[];\n        name: string;\n        years: number;\n        isRegistration?: boolean;\n        address?: string;\n    }) {\n        if (coupons.every((coupon) => typeof coupon === 'string')) {\n            const couponPromises = (coupons as string[]).map(async (couponCode) => {\n                const coupon = await this.resolveCoupon(couponCode);\n                if (!coupon) {\n                    throw new Error(`Coupon not found: ${couponCode}`);\n                }\n\n                return coupon;\n            });\n\n            coupons = (await Promise.all(couponPromises)) as Coupon[];\n        }\n\n        const normalizedName = normalizeIotaName(name, 'dot');\n\n        validateIotaName(normalizedName);\n\n        const nameParts = normalizedName.split('.');\n        const firstNamePart = nameParts[0];\n\n        validateCoupons(coupons, years, firstNamePart.length, address);\n\n        const standardPrice = await this.calculatePrice({\n            name,\n            years,\n            isRegistration,\n        });\n\n        return applyCouponsToPrice(coupons, standardPrice);\n    }\n}\n"],
  "mappings": "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",
  "names": ["import_utils", "import_bcs"]
}
